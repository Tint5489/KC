<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Route Planner</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    body { margin:0; display:flex; height:100vh; font-family:Arial, sans-serif; }
    #sidebar { width:300px; overflow-y:auto; border-right:1px solid #ccc; padding:8px; box-sizing:border-box; }
    #map { flex:1; }
    table { width:100%; border-collapse:collapse; font-size:12px; }
    th, td { border:1px solid #ddd; padding:4px; text-align:left; }
    tr:nth-child(even) { background:#f9f9f9; }
    .number-label { font-size:18px; font-weight:bold; color:red; }
    button { margin-top:6px; padding:6px 10px; cursor:pointer; }
  </style>
</head>
<body>
  <div id="sidebar">
    <input type="file" id="gpxFile" accept=".gpx"><br>
    <table id="stopsTable">
      <thead><tr><th>#</th><th>Stop</th></tr></thead>
      <tbody></tbody>
    </table>
    <div id="distance"></div>
    <button id="locBtn">Enable Current Location</button><br>
    <button id="exportBtn">Export GPS</button>
  </div>
  <div id="map"></div>

  <script>
    const map = L.map('map').setView([54.5, -3.2], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom:19
    }).addTo(map);

    let stops = []; // {lat, lon, name, marker}
    let currentLocationMarker = null;
    let locationInterval = null;
    const tbody = document.querySelector("#stopsTable tbody");

    // Add marker with just a number (no circle)
    function addMarker(lat, lon, number) {
      return L.marker([lat, lon], {
        icon: L.divIcon({
          className: "number-label",
          html: number,
          iconSize: [20,20],
          iconAnchor: [10,10]
        })
      }).addTo(map);
    }

    // Update stop numbers on map + table
    function refreshStops() {
      tbody.innerHTML = "";
      stops.forEach((s, i) => {
        if (s.marker) map.removeLayer(s.marker);
        s.marker = addMarker(s.lat, s.lon, i+1);
        const row = document.createElement("tr");
        row.innerHTML = `<td>${i+1}</td><td>${s.name}</td>`;
        tbody.appendChild(row);
      });
      updateDistance();
    }

    // Haversine distance in km
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2-lat1)*Math.PI/180;
      const dLon = (lon2-lon1)*Math.PI/180;
      const a = Math.sin(dLat/2)**2 +
                Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180) *
                Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function updateDistance() {
      let distKm = 0;
      for(let i=1;i<stops.length;i++) {
        distKm += haversine(stops[i-1].lat, stops[i-1].lon, stops[i].lat, stops[i].lon);
      }
      const distMi = distKm*0.621371;
      document.getElementById("distance").innerText =
        `Distance: ${distKm.toFixed(2)} km / ${distMi.toFixed(2)} miles`;
    }

    // Parse GPX file
    document.getElementById("gpxFile").addEventListener("change", function(e){
      const file = e.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = function() {
        const parser = new DOMParser();
        const xml = parser.parseFromString(reader.result, "text/xml");
        const wpts = xml.getElementsByTagName("wpt");

        stops = [];
        for(let w of wpts) {
          const lat = parseFloat(w.getAttribute("lat"));
          const lon = parseFloat(w.getAttribute("lon"));
          const name = w.getElementsByTagName("name")[0]?.textContent || "Stop";
          stops.push({lat, lon, name, marker:null});
        }
        refreshStops();
        if(stops.length>0) {
          const group = L.featureGroup(stops.map(s => L.marker([s.lat,s.lon])));
          map.fitBounds(group.getBounds().pad(0.2));
        }
      }
      reader.readAsText(file);
    });

    // Make table sortable
    new Sortable(tbody, {
      animation:150,
      onEnd: function(){
        const newStops = [];
        tbody.querySelectorAll("tr").forEach(row=>{
          const idx = parseInt(row.querySelector("td").innerText)-1;
          newStops.push(stops[idx]);
        });
        stops = newStops;
        refreshStops();
      }
    });

    // Current location toggle
    document.getElementById("locBtn").addEventListener("click", function(){
      if(locationInterval) {
        clearInterval(locationInterval);
        locationInterval = null;
        if(currentLocationMarker) { map.removeLayer(currentLocationMarker); currentLocationMarker=null; }
        this.innerText = "Enable Current Location";
      } else {
        const updateLoc = () => {
          navigator.geolocation.getCurrentPosition(pos=>{
            const {latitude, longitude} = pos.coords;
            if(currentLocationMarker) {
              currentLocationMarker.setLatLng([latitude, longitude]);
            } else {
              currentLocationMarker = L.marker([latitude, longitude], {
                icon: L.divIcon({
                  className:"number-label",
                  html:"ðŸ“",
                  iconSize:[20,20],
                  iconAnchor:[10,10]
                })
              }).addTo(map);
            }
          });
        };
        updateLoc();
        locationInterval = setInterval(updateLoc, 300000); // 5 min
        this.innerText = "Disable Current Location";
      }
    });

    // Export GPX (only user stops, no Start/End)
    document.getElementById("exportBtn").addEventListener("click", ()=>{
      const userStops = stops; // exporting all current stops (excluding if you wish slice)
      if(userStops.length === 0) return alert("No user stops to export.");

      let gpx = `<?xml version="1.0" encoding="UTF-8" ?>
<gpx version="1.1" 
 creator="Memory-Map 6.4.3.1278 https://memory-map.com"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns="http://www.topografix.com/GPX/1/1"
 xmlns:xstyle="http://www.topografix.com/GPX/gpx_style/0/2"
 xmlns:xgarmin="http://www.garmin.com/xmlschemas/GpxExtensions/v3"
 xsi:schemaLocation="http://www.topografix.com/GPX/1/1 
   http://www.topografix.com/GPX/1/1/gpx.xsd 
   http://www.topografix.com/GPX/gpx_style/0/2 
   http://www.topografix.com/GPX/gpx_style/0/2/gpx_style.xsd 
   http://www.garmin.com/xmlschemas/GpxExtensions/v3 
   https://www8.garmin.com/xmlschemas/GpxExtensionsv3.xsd">\n`;

      let baseHex = 0x9033374E00000000n;

      userStops.forEach((s, idx) => {
        const time = new Date().toISOString();
        const mmid = (baseHex + BigInt(idx)).toString(16).toUpperCase();
        gpx += `<wpt lat="${s.lat}" lon="${s.lon}">
  <time>${time}</time>
  <name>${s.name}</name>
  <src>mmid:${mmid}</src>
  <sym>Dot</sym>
  <type>Marks:Stops</type>
  <extensions>
    <xstyle:fill>
      <xstyle:color>0000ff</xstyle:color>
    </xstyle:fill>
  </extensions>
</wpt>\n`;
      });

      gpx += `</gpx>`;

      const blob = new Blob([gpx], { type: "application/gpx+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "user_stops.gpx";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
