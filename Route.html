<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Route Planner — Start/End + Export</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css"/>

<style>
  :root { --sidebar-width:360px; --blue:#007bff; }
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#fafbfc}
  #map{position:absolute;top:0;left:0;right:0;bottom:0}
  /* Flyout sidebar */
  #sidebar{
    position:fixed; right:0; top:0; height:100vh; width:var(--sidebar-width);
    background:#f9f9f9; border-left:1px solid #ccc; padding:12px; box-sizing:border-box;
    overflow:auto; z-index:1200; transform:translateX(0); transition:transform .28s ease;
  }
  #sidebar.collapsed{ transform:translateX(100%); }
  #sidebarToggle{
    position:fixed; right:0; top:50%; transform:translateY(-50%);
    width:36px; height:54px; background:var(--blue); color:white; display:flex;
    align-items:center; justify-content:center; font-size:20px; cursor:pointer; z-index:2000;
    border-radius:6px 0 0 6px;
  }

  h2{margin:4px 0 10px 0; font-size:18px}
  label{display:block; margin-bottom:6px; font-size:13px}
  input[type=file]{width:100%;}

  .controls{display:flex; gap:8px; margin:8px 0 10px 0; flex-wrap:wrap}
  .controls button{padding:6px 10px; cursor:pointer; border-radius:6px; border:1px solid #ccc; background:white}
  .controls button.primary{background:var(--blue); color:#fff; border-color:var(--blue)}

  #routeInfo{margin-top:8px; font-weight:600; color:#333}

  .table-container{background:#fff;border:2px solid #dadada;border-radius:6px;padding:6px; box-shadow:0 2px 8px -2px #bbb; overflow:auto; margin-top:10px}
  table{border-collapse:collapse;width:100%; font-size:13px}
  th,td{padding:4px 6px;border:1px solid #ddd; text-align:left}
  tr{cursor:grab}
  tr.dragging{background:#ffeeba}

  /* Big plain number labels (no circle) */
  .leaflet-div-icon {
    background:none!important;border:none!important;box-shadow:none!important;
    font-weight:bold;font-size:24px;color:var(--blue);text-align:center;
  }

  @media(max-width:820px){
    #sidebar{width:92vw; min-width:200px}
    #sidebarToggle{right:auto;left:0;border-radius:0 6px 6px 0}
  }
</style>
</head>
<body>

<div id="map"></div>

<div id="sidebarToggle" title="Toggle sidebar">&#x25B6;</div>

<aside id="sidebar" class="">
  <h2>Route Planner</h2>

  <label for="fileInput">Import stops from GPX file</label>
  <input id="fileInput" type="file" accept=".gpx"/>

  <div class="controls">
    <button id="toggleLocationBtn">Show Current Location</button>
    <button id="exportBtn">Export GPS (user stops)</button>
  </div>

  <div id="routeInfo">Total distance: 0 km / 0 mi, Estimated time: 0h 0m</div>

  <div class="table-container" id="tableContainer" style="height:300px">
    <table id="stopsTable">
      <thead><tr><th style="width:36px">#</th><th>Stop</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</aside>

<!-- libs -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>

<script>
/* ---------------------
   Configuration & state
   --------------------- */
const WORK_START = { name:"Start", lat:54.971723, lon:-2.949500 };
const WORK_STOP  = { name:"End",   lat:54.971730, lon:-2.949550 };

let stops = [WORK_START, WORK_STOP]; // always include start & end
let stopLabels = [];                 // leaflet markers for numbers
let routingControl = null;
let sortable = null;

let currentLocationMarker = null;
let locationInterval = null;
let locationEnabled = false;

/* DOM */
const sidebar = document.getElementById('sidebar');
const toggleBtn = document.getElementById('sidebarToggle');
const tbody = document.querySelector("#stopsTable tbody");
const routeInfoEl = document.getElementById("routeInfo");
const tableContainer = document.getElementById("tableContainer");
const fileInput = document.getElementById("fileInput");
const toggleLocationBtn = document.getElementById("toggleLocationBtn");
const exportBtn = document.getElementById("exportBtn");

/* Map */
const DEFAULT_CENTER = [54.58303,-2.56954];
const DEFAULT_ZOOM = 6;
const map = L.map('map').setView(DEFAULT_CENTER, DEFAULT_ZOOM);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
  attribution:'&copy; OpenStreetMap contributors'
}).addTo(map);

/* Utility: remove all labels */
function removeStopLabels(){
  stopLabels.forEach(l=>map.removeLayer(l));
  stopLabels = [];
}

/* Add plain-number labels at stops (no circles) */
function addStopLabels(){
  removeStopLabels();
  stops.forEach((s,i)=>{
    const color = (i===0) ? '#007bff' : (i===stops.length-1) ? '#ff0000' : '#28a745';
    const label = L.marker([s.lat,s.lon], {
      icon: L.divIcon({
        className:'leaflet-div-icon',
        html:`<span style="color:${color}">${i+1}</span>`,
        iconSize:[28,28],
        iconAnchor:[14,14]
      }),
      interactive:false
    }).addTo(map);
    stopLabels.push(label);
  });
}

/* Update table contents */
function updateTable(){
  tbody.innerHTML = '';
  stops.forEach((s,i)=>{
    const tr = document.createElement('tr');
    tr.dataset.index = i;
    tr.innerHTML = `<td>${i+1}</td><td>${escapeHtml(s.name||'Stop')}</td>`;
    tbody.appendChild(tr);
  });
}

/* Resize table container to fit rows (auto-fit) */
function resizeTableToFitRows(){
  const rowHeight = 30; // approx
  const headerHeight = 36;
  const padding = 12;
  const totalRows = stops.length;
  const max = 600;
  const computed = Math.min(headerHeight + totalRows * rowHeight + padding, max);
  tableContainer.style.height = computed + 'px';
  setTimeout(()=>map.invalidateSize(),100);
}

/* Safe escape for names */
function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, (m)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

/* ROUTE: create or recreate routing control.
   fitBounds: if true, fit map to route bounds (used only on GPX load)
*/
function updateRoute(fitBounds=false){
  if(routingControl){ map.removeControl(routingControl); routingControl=null; }

  if(stops.length < 2){
    routeInfoEl.textContent = 'Total distance: 0 km / 0 mi, Estimated time: 0h 0m';
    removeStopLabels();
    return;
  }

  const waypoints = stops.map(s => L.latLng(s.lat, s.lon));

  routingControl = L.Routing.control({
    waypoints,
    createMarker: () => null,      // don't let LRM create default markers
    addWaypoints: false,
    draggableWaypoints: false,
    fitSelectedRoutes: false,
    lineOptions: { styles: [{ color:'#007bff', weight:4, opacity:0.85 }] },
    show: false
  }).addTo(map);

  addStopLabels();

  routingControl.on('routesfound', e=>{
    const route = e.routes && e.routes[0];
    if(route && route.summary){
      const distMeters = route.summary.totalDistance || 0;
      const timeSec = route.summary.totalTime || 0;
      const distKm = (distMeters / 1000);
      const distMi = distMeters * 0.000621371;
      const hours = Math.floor(timeSec / 3600);
      const mins = Math.round((timeSec % 3600) / 60);
      routeInfoEl.textContent = `Total distance: ${distKm.toFixed(1)} km / ${distMi.toFixed(1)} mi, Estimated time: ${hours}h ${mins}m`;
    } else {
      // fallback: straight-line sum of segments (if routing provider failed)
      let km=0;
      for(let i=1;i<stops.length;i++){
        km += haversineKm(stops[i-1].lat,stops[i-1].lon,stops[i].lat,stops[i].lon);
      }
      const miles = km * 0.621371;
      routeInfoEl.textContent = `Total distance: ${km.toFixed(1)} km / ${miles.toFixed(1)} mi, Estimated time: N/A`;
    }
  });

  if(fitBounds){
    // bounds from stops
    const bounds = L.latLngBounds(stops.map(s=>[s.lat,s.lon]));
    map.fitBounds(bounds.pad(0.12));
  }
}

/* Haversine distance helper (km) used as fallback */
function haversineKm(lat1, lon1, lat2, lon2){
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI/180;
  const dLon = (lon2 - lon1) * Math.PI/180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

/* Sortable table initialization */
function initSortable(){
  if(sortable) { try{ sortable.destroy(); }catch(e){} }
  sortable = Sortable.create(tbody, {
    handle: 'td',
    animation: 160,
    onEnd: function(){
      // Convert table order into new stops array
      const newStops = [];
      tbody.querySelectorAll('tr').forEach(row=>{
        const oldIndex = parseInt(row.dataset.index,10);
        newStops.push(stops[oldIndex]);
      });
      // ensure first/last remain start/end (they are included in stops)
      stops = [newStops[0], ...newStops.slice(1, -1), newStops[newStops.length - 1]];
      updateTable();
      updateRoute(false); // don't fit map
      resizeTableToFitRows();
      initSortable();
    }
  });
}

/* File input behaviour:
   - clicking file input clears intermediate stops but preserves start/end
   - reset file input value so same file can be re-picked
*/
fileInput.addEventListener('click', ()=>{
  stops = [WORK_START, WORK_STOP];
  updateTable(); removeStopLabels(); updateRoute(false); resizeTableToFitRows();
  fileInput.value = '';
});

/* GPX import: parse and insert user stops between Start & End */
fileInput.addEventListener('change', async (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  try{
    const txt = await f.text();
    const xml = new DOMParser().parseFromString(txt, 'text/xml');
    // prefer togeojson if file includes trkpt or wpt; support both
    const geojson = toGeoJSON.gpx(xml);
    // find point features: Point geometry (wpt or trkpt converted)
    const pts = (geojson.features || []).filter(ft => ft.geometry && ft.geometry.type === 'Point');
    const userStops = pts.map(ft => ({
      name: ft.properties.name || ft.properties.desc || 'Stop',
      lat: ft.geometry.coordinates[1],
      lon: ft.geometry.coordinates[0]
    }));

    // always wrap with Start/End
    stops = [WORK_START, ...userStops, WORK_STOP];
    updateTable();
    initSortable();
    resizeTableToFitRows();
    updateRoute(true); // fit map on GPX load

    // reset file input so same file can be selected again later
    fileInput.value = '';
  }catch(err){
    alert('Failed to import GPX: ' + (err && err.message ? err.message : err));
  }
});

/* Toggle sidebar */
toggleBtn.addEventListener('click', ()=>{
  sidebar.classList.toggle('collapsed');
  toggleBtn.innerHTML = sidebar.classList.contains('collapsed') ? '&#x25C0;' : '&#x25B6;';
  setTimeout(()=>map.invalidateSize(), 220);
});
window.addEventListener('load', ()=>{ sidebar.classList.remove('collapsed'); toggleBtn.innerHTML='&#x25B6;'; });

/* Current location: poll every 5 minutes when enabled */
function updateCurrentLocationOnce(){
  if(!navigator.geolocation) { console.warn('Geolocation unsupported'); return; }
  navigator.geolocation.getCurrentPosition(pos=>{
    const lat = pos.coords.latitude, lon = pos.coords.longitude;
    if(!currentLocationMarker){
      currentLocationMarker = L.marker([lat, lon], {
        title: 'You are here',
        icon: L.icon({
          iconUrl: 'https://cdn-icons-png.flaticon.com/512/64/64113.png',
          iconSize: [24,24], iconAnchor: [12,12]
        })
      }).addTo(map);
    } else {
      currentLocationMarker.setLatLng([lat, lon]);
    }
  }, err=> console.warn('Geolocation error', err), { enableHighAccuracy:true });
}

toggleLocationBtn.addEventListener('click', ()=>{
  if(!locationEnabled){
    updateCurrentLocationOnce();
    locationInterval = setInterval(updateCurrentLocationOnce, 5 * 60 * 1000);
    toggleLocationBtn.textContent = 'Hide Current Location';
    locationEnabled = true;
  } else {
    if(currentLocationMarker){ map.removeLayer(currentLocationMarker); currentLocationMarker = null; }
    clearInterval(locationInterval);
    locationInterval = null;
    toggleLocationBtn.textContent = 'Show Current Location';
    locationEnabled = false;
  }
});

/* Export GPX (Memory-Map compatible) — user stops ONLY (exclude Start & End).
   mmid sequence: start from a stable base and increment for each wpt.
*/
exportBtn.addEventListener('click', ()=> {
  // user stops are stops[1..n-2]
  const userStops = stops.slice(1, -1);
  if(userStops.length === 0){ alert('No user stops to export.'); return; }

  let gpx = `<?xml version="1.0" encoding="UTF-8" ?>
<gpx version="1.1"
 creator="Memory-Map 6.4.3.1278 https://memory-map.com"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns="http://www.topografix.com/GPX/1/1"
 xmlns:xstyle="http://www.topografix.com/GPX/gpx_style/0/2"
 xmlns:xgarmin="http://www.garmin.com/xmlschemas/GpxExtensions/v3"
 xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd http://www.topografix.com/GPX/gpx_style/0/2 http://www.topografix.com/GPX/gpx_style/0/2/gpx_style.xsd http://www.garmin.com/xmlschemas/GpxExtensions/v3 https://www8.garmin.com/xmlschemas/GpxExtensionsv3.xsd">\n`;

  // base (hex-like) number - keep it consistent per export (but you can randomize if you prefer)
  let baseHex = 0x9033374E00000000n;

  userStops.forEach((s, idx) => {
    const time = new Date().toISOString();
    const mmid = (baseHex + BigInt(idx)).toString(16).toUpperCase();
    gpx += `<wpt lat="${s.lat}" lon="${s.lon}">
  <time>${time}</time>
  <name>${escapeXml(s.name)}</name>
  <src>mmid:${mmid}</src>
  <sym>Dot</sym>
  <type>Marks:Stops</type>
  <extensions>
    <xstyle:fill>
      <xstyle:color>0000ff</xstyle:color>
    </xstyle:fill>
  </extensions>
</wpt>\n`;
  });

  gpx += `</gpx>`;

  const blob = new Blob([gpx], { type: 'application/gpx+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'user_stops.gpx';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

function escapeXml(s){
  return String(s).replace(/[<>&'"]/g, c=>({ '<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;'}[c]));
}

/* initial render */
updateTable();
initSortable();
resizeTableToFitRows();
updateRoute(false);
addStopLabels();

</script>
</body>
</html>
